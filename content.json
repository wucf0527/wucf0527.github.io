{"meta":{"title":"wcf","subtitle":"无","description":"无","author":"wucf","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2022-02-16T07:21:43.000Z","updated":"2022-02-16T08:23:40.226Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-02-16T07:21:48.000Z","updated":"2022-02-16T08:25:01.777Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"ReentrantLock和AQS详解","slug":"ReentrantLock和AQS详解","date":"2022-05-18T15:05:29.000Z","updated":"2022-05-21T11:42:19.664Z","comments":true,"path":"2022/05/18/ReentrantLock和AQS详解/","link":"","permalink":"http://example.com/2022/05/18/ReentrantLock%E5%92%8CAQS%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"AQS本质指的AbstractQueuedSynchronizer类 类中有几个关键属性加上 clh双向队列组成 源码详解aqs中的内部类 node节点和队列node就是aqs内部队列里面的每个节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static final class Node &#123; //作为共享模式（可重入） static final Node SHARED = new Node();//排他锁的表示 （独占锁） static final Node EXCLUSIVE = null;//标识失效 static final int CANCELLED = 1; //后续节点需要唤醒 static final int SIGNAL = -1; //等待状态：表示线程正在等待条件 static final int CONDITION = -2; //等待状态：表示下一个共享模式的节点应该无条件的传播下去 static final int PROPAGATE = -3;// //等待状态，初始化为0，剩下的状态就是上面列出的 volatile int waitStatus; //队列上一个节点，也叫前驱节点 volatile Node prev; //队列下一个节点，也叫后续节点 volatile Node next; //当前节点的线程 volatile Thread thread; /** * Link to next node waiting on condition, or the special * value SHARED. Because condition queues are accessed only * when holding in exclusive mode, we just need a simple * linked queue to hold nodes while they are waiting on * conditions. They are then transferred to the queue to * re-acquire. And because conditions can only be exclusive, * we save a field by using special value to indicate shared * mode. */ Node nextWaiter; //是否是共享节点 final boolean isShared() &#123; return nextWaiter == SHARED; &#125; //返回前驱节点。 如果前驱节点为null抛出异常 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125; &#125; aqs类中123456789101112131415 //表示头节点private transient volatile Node head; /** * Tail of the wait queue, lazily initialized. Modified only via * method enq to add new wait node. *///表示尾部节点 private transient volatile Node tail; /** * The synchronization state. */ private volatile int state; aqs中的head 和tail 指向 头尾节点，队列里面的所有节点的 prve 和next 指向上一节点和下一节点。 aqs中的队列大概是这么一个结构。 1234567/** +------+ prev +-----+ +-----+ head | | &lt;---- | | &lt;---- | | tail +------+ +-----+ +-----+*/源码中有这样一个图 独占锁和共享锁ReentrantLock中的公平锁运行及源码解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 ReentrantLock.lock 里面调用了这个方法public final void acquire(int arg) &#123; //tryAcquire(arg)成功后 返回true ！的作用返回false //尝试加锁失败后 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) if (!tryAcquire(arg) &amp;&amp; //解析在下面 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125;protected final boolean tryAcquire(int acquires) &#123; //获取当前线程 final Thread current = Thread.currentThread();‘ //获取锁的状态 0代表没人使用，大于零代表有线程使用，和可重入 int c = getState(); if (c == 0) &#123; // 当锁没人使用的时候，首先判断自己是否需要排队，如果不需要排队，cas修改锁的状态并且 setExclusiveOwnerThread(current); if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //可重入锁的体现 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; &#125; private Node addWaiter(Node mode) &#123; //首先new一个节点 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node; &#125; //初始化队列和插入节点 final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); //判断头尾是否一样 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; final Node predecessor() throws NullPointerException &#123; //获取下个节点 复制给node p Node p = prev; //如果下个节点为空 抛出异常，如果下个节点不为空返回该节点 if (p == null) throw new NullPointerException(); else return p; &#125; ReentrantLock加锁过程源码分析加锁流程图 入队流程即源码解析队列结构 贯通全局的例子假设有三个并发的线程 T1 T2 T3 这三个线程出现了资源争抢 t1最先执行其次t2 t3 t1做的操作： 判断锁是否再用（否） 判断自己是否需要排队（否） cas修改锁的状态 t2： 判断锁是否再用（是） 判断自己是否需要排队（是） 判断队列是否为空（是） 创建一个Thread属性为自己的node 和一个空node 把队列的头指向空node，队列的尾部指向创建一个Thread属性为自己的node t3： 判断锁是否再用（是） 判断自己是否需要排队（是） 判断队列是否为空（否） 把自己的上一个节点指向当前队列的尾部（对于当前例子来说就是t2），cas修改队列的尾部为t3，修改t2的下一个节点为t3 再后来的节点都是同t3 入队流程结束 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 public final void acquire(int arg) &#123; //t1 加锁成功 //t2 tryAcquire(arg)加锁失败 //t3 tryAcquire(arg)加锁失败 if (!tryAcquire(arg) &amp;&amp; //t2 addWaiter //t3 addWaiter acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; //t1 hasQueuedPredecessors（不需要排队）-》compareAndSetState //t2 hasQueuedPredecessors false 不往下执行 //t3 hasQueuedPredecessors false 不往下执行 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; &#125;//最下层的，判断自己是否需要排队 public final boolean hasQueuedPredecessors() &#123; //获取头尾节点 Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; //头尾节点是否相等，!的作用下不相等为false 代表需要排队 需要排队直接进入加锁失败 return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); &#125; private Node addWaiter(Node mode) &#123; //创建一个node节点，线程为当前线程 t2 t3 Node node = new Node(Thread.currentThread(), mode); // t2 由于队列还没初始化，tail为空 所以执行neq（） //t3 的时候tail为t2 不等于空 Node pred = tail; //t3 把自己的上一个节点指向当前队列的尾部（对于当前例子来说就是t2），cas修改队列的尾部为t3，修改t2的下一个节点为t3 if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //t2执行 enq(node); return node; &#125; //t2执行 private Node enq(final Node node) &#123; //死循环 for (;;) &#123; //第一次循环 tail为null t为null //第二次循环 tail 为空node 不等于null 进入else Node t = tail; if (t == null) &#123; //第一次循环 new一个空node cas 设置为队列的头部 if (compareAndSetHead(new Node())) //第一次循环 设置尾部为空node //第一次循环结束 tail = head; &#125; else &#123; //第二次循环 设置当前node的上一个节点为t node.prev = t; //第二次循环 cas修改当前节点为队列尾部 // t2入队操作结束 if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125;","categories":[],"tags":[]},{"title":"ReentrantReadWriteLock","slug":"ReentrantReadWriteLock","date":"2022-05-17T11:36:43.000Z","updated":"2022-05-17T11:59:11.102Z","comments":true,"path":"2022/05/17/ReentrantReadWriteLock/","link":"","permalink":"http://example.com/2022/05/17/ReentrantReadWriteLock/","excerpt":"","text":"ReentrantReadWriteLockReentrantReadWriteLock是读写锁，适用场景为读多写少的场景，当读锁被获取的时候不允许获取写锁。一个线程可以同时获取读写锁，但是要先获取写锁再获取读锁，不然就会死锁 别人的总结ReentrantReadWriteLock 是读写锁，和ReentrantLock会有所不同，对于读多写少的场景使用ReentrantReadWriteLock 性能会比ReentrantLock高出不少。在多线程读时互不影响，不像ReentrantLock即使是多线程读也需要每个线程获取锁。不过任何一个线程在写的时候就和ReentrantLock类似，其他线程无论读还是写都必须获取锁。需要注意的是同一个线程可以拥有 writeLock 与 readLock (但必须先获取 writeLock 再获取 readLock, 反过来进行获取会导致死锁) 例子12345678910111213141516171819202122232425262728293031323334353637383940//封装一个map 使用读写锁private static Map&lt;String,String&gt; map = new TreeMap&lt;String,String&gt;(); private static ReentrantReadWriteLock lock=new ReentrantReadWriteLock(); public String get (String key)&#123; lock.readLock().lock(); try &#123; return map.get(key); &#125;finally &#123; lock.readLock().unlock(); &#125; &#125; public Set&lt;String&gt; getAllKeys()&#123; lock.readLock().lock(); try &#123; return map.keySet(); &#125;finally &#123; lock.readLock().unlock(); &#125; &#125; public void put(String key,String value)&#123; lock.writeLock().lock(); try &#123; map.put(key,value); &#125;finally &#123; lock.writeLock().unlock(); &#125; &#125; 用map做一个小例子简单理解 如果实际中读操作远远大于写操作，那么使用ReentrantReadWriteLock就是不合适的，有可能会因为一直在读，写的操作一直无法执行，所以应该在读少写多的时候使用该锁 总结 ReentrantReadWriteLock适合读少写多的场景 ReentrantReadWriteLock使用了读写分离的策略，读操作直接互不影响，有读锁的时候不允许获得写锁。 ReentrantLock是独占锁，ReentrantReadWriteLock允许多个线程同时获取读锁。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"ReentrantLock预习","slug":"ReentrantLock预习","date":"2022-05-16T15:10:40.000Z","updated":"2022-05-16T15:34:54.493Z","comments":true,"path":"2022/05/16/ReentrantLock预习/","link":"","permalink":"http://example.com/2022/05/16/ReentrantLock%E9%A2%84%E4%B9%A0/","excerpt":"","text":"ReentrantLock和Synchronized ReentrantLock Synchronized 锁机制实现 依赖AQS 监视器模式 灵活性 支持响应中断，超时，尝试获得锁 不灵活 释放形式 手动调用unlock 监视器自动释放 锁类型 公平锁和非公平锁 非公平锁 条件队列 可关联多个队列 关联一个队列 可重入性 可重入 可重入 123456789101112131415161718192021222324252627282930// **************************Synchronized的使用方式**************************// 1.用于代码块synchronized (this) &#123;&#125;// 2.用于对象synchronized (object) &#123;&#125;// 3.用于方法public synchronized void test () &#123;&#125;// 4.可重入for (int i = 0; i &lt; 100; i++) &#123; synchronized (this) &#123;&#125;&#125;// **************************ReentrantLock的使用方式**************************public void test () throw Exception &#123; // 1.初始化选择公平锁、非公平锁 ReentrantLock lock = new ReentrantLock(true); // 2.可用于代码块 lock.lock(); try &#123; try &#123; // 3.支持多种加锁方式，比较灵活; 具有可重入特性 if(lock.tryLock(100, TimeUnit.MILLISECONDS))&#123; &#125; &#125; finally &#123; // 4.手动释放锁 lock.unlock() &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 参考文章https://blog.csdn.net/zhengzhaoyang122/article/details/110847701 简单计数使用例子 12345678910111213141516171819202122232425262728293031323334353637383940414243public static int clientTotal=5000;public static int ThteadTotal=200;public static int count=0;public static Lock lock=new ReentrantLock();public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore=new Semaphore(ThteadTotal); final CountDownLatch countDownLatch=new CountDownLatch(clientTotal); for (int i=1;i&lt;=clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire(); //争抢方法 add(); //释放 semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(count+&quot;&quot;);&#125;private static void add()&#123; //很简单的使用方式 lock.lock(); count++; lock.unlock();&#125; 核心方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** * 阻塞等待获取锁;不允许Thread.interrupt中断,即使检测到Thread.isInterrupted,一样会继续尝试 * 获取锁，失败则继续休眠。只是在最后获取锁成功后再把当前线程置为interrupted状态,然后再中断线程。 */ public void lock() &#123; sync.lock(); &#125; /** * 当前线程未被中断，则获取锁 * 允许在等待时由其它线程调用等待线程的Thread.interrupt方法来中断等待线程的等待而直接返回，这时 * 不用获取锁，而会抛出一个InterruptedException */ public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; /** *尝试申请一个锁，在成功获得锁后返回true，否则，立即返回false */ public boolean tryLock() &#123; return sync.nonfairTryAcquire(1); &#125; /** * 在一段时间内尝试申请一个锁，在成功获得锁后返回true，否则，立即返回false */ public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; /** * 释放锁 */ public void unlock() &#123; sync.release(1); &#125; /** * 条件实例 */ public Condition newCondition() &#123; return sync.newCondition(); &#125; /** * 获取当前线程持有此锁的次数 */ public int getHoldCount() &#123; return sync.getHoldCount(); &#125; /** * 是否被当前线程持有 */ public boolean isHeldByCurrentThread() &#123; return sync.isHeldExclusively(); &#125; /** * 查询此锁是否由任意线程持有 */ public boolean isLocked() &#123; return sync.isLocked(); &#125; /** *如果是“公平锁”返回true，否则返回false */ public final boolean isFair() &#123; return sync instanceof FairSync; &#125; /** * 获取目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null */ protected Thread getOwner() &#123; return sync.getOwner(); &#125; /** * 查询是否有线程正在等待 */ public final boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; /** *查询给定线程是否正在等待获取此锁。 */ public final boolean hasQueuedThread(Thread thread) &#123; return sync.isQueued(thread); &#125; /** * 获取正等待获取此锁的线程数 */ public final int getQueueLength() &#123; return sync.getQueueLength(); &#125; /** * 正等待获取此锁的线程集合 */ protected Collection&lt;Thread&gt; getQueuedThreads() &#123; return sync.getQueuedThreads(); &#125; /** *是否存在正在等待并符合相关给定条件的线程 */ public boolean hasWaiters(Condition condition) &#123; if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException(&quot;not owner&quot;); return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition); &#125; /** * 正在等待并符合相关给定条件的线程数量 */ public int getWaitQueueLength(Condition condition) &#123; if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException(&quot;not owner&quot;); return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition); &#125; /** * 正在等待并符合相关给定条件的线程集合 */ protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition) &#123; if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException(&quot;not owner&quot;); return sync.getWaitingThreads((AbstractQueuedSynchronizer.ConditionObject)condition); &#125; 总结小预习 明天深入","categories":[],"tags":[]},{"title":"AQS.cyclicBarrier","slug":"AQS-cyclicBarrier","date":"2022-05-14T10:21:15.000Z","updated":"2022-05-15T11:18:37.663Z","comments":true,"path":"2022/05/14/AQS-cyclicBarrier/","link":"","permalink":"http://example.com/2022/05/14/AQS-cyclicBarrier/","excerpt":"","text":"CyclicBarrierCyclicBarrier 理解为循环围栏，可以做是一个可重置的定时器，提供了reset方法，与countdownLacth不同。 作用是 让一组线程达到一个同步点的时候被阻塞，直到最后一个线程达到同步点再继续执行接下来的操作。 构造函数12345678910111213 //有parties个线程调用了 CyclicBarrier的await方法 才继续执行线程后续操作public CyclicBarrier(int parties) &#123; this(parties, null); &#125; //有parties个线程调用了 CyclicBarrier的await方法 首先执行barrierAction 然后执行被同步的线程后续操作 public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction; &#125; 关键方法和使用例子123456789101112131415161718192021222324252627282930313233 public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125; &#125;//设置超时时间 超过时间会抛出异常，如果想要不影响程序运行 可以捕获 public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; return dowait(true, unit.toNanos(timeout)); &#125;//重置计数器 public void reset() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; breakBarrier(); // break the current generation nextGeneration(); // start a new generation &#125; finally &#123; lock.unlock(); &#125; &#125; 例子 12345678910111213141516171819202122232425262728293031323334353637383940414243private static CyclicBarrier cyclicBarrier=new CyclicBarrier(5);private static CyclicBarrier cyclicBarrier2=new CyclicBarrier(5,()-&gt;&#123; log.info(&quot;满足条件首先调用 &#123;&#125;&quot;,&quot;cyclicBarrier2&quot;);&#125;);public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i=0;i&lt;10;i++)&#123; final int threadNum=i; Thread.sleep(1000); executorService.execute(()-&gt;&#123; try &#123; test(threadNum); &#125; catch (Exception e) &#123; log.info(&quot;Exception &#123;&#125;&quot;,e); &#125; &#125;); &#125; executorService.shutdown();&#125;//await 不传入参数public static void test(int threadNum) throws Exception &#123; Thread.sleep(1000); log.info(&quot;Thread &#123;&#125; ready&quot;,threadNum); cyclicBarrier2.await(); log.info(&quot;Thread &#123;&#125; continue&quot;,threadNum);&#125;//await 传入超时时间public static void test2(int threadNum) throws Exception &#123; Thread.sleep(1000); log.info(&quot;Thread &#123;&#125; ready&quot;,threadNum); try &#123; cyclicBarrier.await(2, TimeUnit.SECONDS); &#125;catch (BrokenBarrierException|TimeoutException e)&#123; log.info(&quot;BarrierException &#123;&#125;&quot;,e); &#125; log.info(&quot;Thread &#123;&#125; continue&quot;,threadNum);&#125; 简单放一个 运行结果 1234567891018:34:03.048 [pool-1-thread-1] INFO com.imooc.concurrency.aqs.CyclicBarrierExample1 - Thread 0 ready18:34:04.046 [pool-1-thread-2] INFO com.imooc.concurrency.aqs.CyclicBarrierExample1 - Thread 1 ready18:34:05.059 [pool-1-thread-3] INFO com.imooc.concurrency.aqs.CyclicBarrierExample1 - Thread 2 ready18:34:06.066 [pool-1-thread-4] INFO com.imooc.concurrency.aqs.CyclicBarrierExample1 - Thread 3 ready18:34:07.075 [pool-1-thread-5] INFO com.imooc.concurrency.aqs.CyclicBarrierExample1 - Thread 4 ready18:34:07.075 [pool-1-thread-5] INFO com.imooc.concurrency.aqs.CyclicBarrierExample1 - Thread 4 continue18:34:07.075 [pool-1-thread-2] INFO com.imooc.concurrency.aqs.CyclicBarrierExample1 - Thread 1 continue18:34:07.075 [pool-1-thread-1] INFO com.imooc.concurrency.aqs.CyclicBarrierExample1 - Thread 0 continue18:34:07.075 [pool-1-thread-3] INFO com.imooc.concurrency.aqs.CyclicBarrierExample1 - Thread 2 continue18:34:07.076 [pool-1-thread-4] INFO com.imooc.concurrency.aqs.CyclicBarrierExample1 - Thread 3 continue 可以看到，有五个线程 reday的时候 所有被同步的线程才开始继续运行 CountDownLatch和CyclicBarrier的区别 CyclicBarrier可以重复使用 通过reset方法重置，countdownLatch只能使用一次 CyclicBarrier的工作线程完成任务后，在屏障点到达前，会一直等待，也就是会存在多个线程同时等待的情况；而CountDownLatch的主线程会await阻塞在那里，工作线程完成任务后可以一般都会终止。 CountDownLatch 减计数 CyclicBarrier加计数 CountDownLatch计数为零的时候释放所有调用await的线程，CyclicBarrier到达屏障值的时候释放等待的线程。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"AQS.semaphore","slug":"AQS-semaphore","date":"2022-05-13T10:06:50.000Z","updated":"2022-05-13T10:25:23.294Z","comments":true,"path":"2022/05/13/AQS-semaphore/","link":"","permalink":"http://example.com/2022/05/13/AQS-semaphore/","excerpt":"","text":"Semaphore使用场景和概念Semaphore是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。 常用在控制数据库链接的获取中，开发中数据库链接一般是有限的。 构建方法参数permits代表同一时间可以有多少个许可可以被获取，当一个线程只获取一个许可的时候 也可以看作同一时间有多少线程执行。 12345678910111213141516171819public Semaphore(int permits) &#123; sync = new NonfairSync(permits); &#125; /** * Creates a &#123;@code Semaphore&#125; with the given number of * permits and the given fairness setting. * * @param permits the initial number of permits available. * This value may be negative, in which case releases * must occur before any acquires will be granted. * @param fair &#123;@code true&#125; if this semaphore will guarantee * first-in first-out granting of permits under contention, * else &#123;@code false&#125; */ public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits); &#125; 核心方法acquire 获取许可 Semaphore提供了acquire 方法来获取一个许可 通过传入参数控制 获取一个或者多个。 1234567public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; public void acquire(int permits) throws InterruptedException &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.acquireSharedInterruptibly(permits); &#125; release 释放许可 和获取相反 12345678910public void release(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.releaseShared(permits);&#125;public void release() &#123; sync.releaseShared(1);&#125; tryAcquire 尝试获取许可 123456789101112131415161718192021222324//尝试获取一个许可public boolean tryAcquire() &#123; return sync.nonfairTryAcquireShared(1) &gt;= 0; &#125;//尝试获取一个许可 设置超时时间 如5秒内 如果获取到许可就执行 获取不到就遗弃 public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); &#125;//尝试获取多个许可permits public boolean tryAcquire(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); return sync.nonfairTryAcquireShared(permits) &gt;= 0; &#125;//尝试获取多个许可并设置 超时时间 public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException &#123; if (permits &lt; 0) throw new IllegalArgumentException(); return sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout)); &#125; 抄来的总结Semaphore是一个有效的流量控制工具，它基于AQS共享锁实现。我们常常用它来控制对有限资源的访问。 每次使用资源前，先申请一个或多个信号量，如果资源数不够，就会阻塞等待； 每次释放资源后，就释放一个或多个信号量。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"AQS.CountDownLatch","slug":"AQS-CountDownLatch","date":"2022-05-12T11:14:53.000Z","updated":"2022-05-12T11:32:03.636Z","comments":true,"path":"2022/05/12/AQS-CountDownLatch/","link":"","permalink":"http://example.com/2022/05/12/AQS-CountDownLatch/","excerpt":"","text":"CountDownLatch简单他是一个计数器，线程安全的计数器 CountDownLatch提供了两个重要的方法 countDown（）和 wait（） countDown（）的作用是使计数器减一 try catch finally 这个结果 finally可以保证countDown（）的一定执行 wait（）主线程会进入等待状态，等计数器归零后唤醒，wait可以传入参数控制等待时间，超过设置的等待时间会直接执行下面的语句。 举个粒子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 private static int i=200; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); CountDownLatch countDownLatch = new CountDownLatch(i); for (int a=0;a&lt;200;a++)&#123; final int threadNum=a; executorService.execute(()-&gt;&#123; try &#123; test(threadNum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; countDownLatch.countDown(); &#125; &#125;); &#125; countDownLatch.await(10, TimeUnit.MILLISECONDS); executorService.shutdown(); log.info(&quot;countDownLatch的剩余量:&#123;&#125;&quot;,countDownLatch.getCount()); log.info(&quot;finfish&quot;); &#125; public static void test(int x) throws InterruptedException &#123; log.info(&quot;count count count,&#123;&#125;&quot;,x); &#125;运行结果最后三行19:26:02.535 [pool-1-thread-64] INFO com.imooc.concurrency.aqs.CountDownLatchExample - count count count,6319:26:02.536 [pool-1-thread-77] INFO com.imooc.concurrency.aqs.CountDownLatchExample - count count count,7619:26:02.550 [main] INFO com.imooc.concurrency.aqs.CountDownLatchExample - countDownLatch的剩余量:019:26:02.551 [main] INFO com.imooc.concurrency.aqs.CountDownLatchExample - finfish在没有超过等待时间的时候 主线程等到countDownLatch归0的时候 才继续执行 log.info(&quot;countDownLatch的剩余量:&#123;&#125;&quot;,countDownLatch.getCount()); log.info(&quot;finfish&quot;);这两行输出语句如果我们让test方法超过等待时间 public static void test(int x) throws InterruptedException &#123; Thread.sleep(100); log.info(&quot;count count count,&#123;&#125;&quot;,x); &#125;运行结果：19:27:58.962 [main] INFO com.imooc.concurrency.aqs.CountDownLatchExample - countDownLatch的剩余量:20019:27:58.966 [main] INFO com.imooc.concurrency.aqs.CountDownLatchExample - finfish19:27:59.039 [pool-1-thread-62] INFO com.imooc.concurrency.aqs.CountDownLatchExample - count count count,61 主线程不再等待创建的线程执行 直接执行了下面的输出语句 同时创建的线程也在执行 CountDownLatch的用法CountDownLatch典型用法1：某一线程在开始运行前等待n个线程执行完毕。将CountDownLatch的计数器初始化为n new CountDownLatch(n) ，每当一个任务线程执行完毕，就将计数器减1 countdownlatch.countDown()，当计数器的值变为0时，在CountDownLatch上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。 CountDownLatch典型用法2：实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的CountDownLatch(1)，将其计数器初始化为1，多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为0，多个线程同时被唤醒。 总结无","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"AQS的基础概念","slug":"AQS的基础概念","date":"2022-05-11T10:23:01.000Z","updated":"2022-05-11T10:53:15.710Z","comments":true,"path":"2022/05/11/AQS的基础概念/","link":"","permalink":"http://example.com/2022/05/11/AQS%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","excerpt":"","text":"前言网上aqs相关的文章很多很详细 也很好理解，摘录到文章里，着重记录好理解的概念。 https://zhuanlan.zhihu.com/p/378219920（AQS从原理到很多具体使用 很多常用类都有单独的解析 写的很不错） https://blog.csdn.net/wwwzhouzy/article/details/119702170 ​ ​ 什么是AQSAQS 的全称为（AbstractQueuedSynchronizer） AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器， 比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask(jdk1.7) 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。 AQS 原理概览AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒 时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 简单总结一下自己的理解，多个线程访问共享数据，通过获取锁的方式，获取到锁的那个线程执行对共享数据的操作，未获取到锁的线程进入到队列中阻塞，等待唤醒。 AQS定义的两种资源共享方式 Exclusive（独占） 字面意思 通过锁的方式 同一时间只有一个线程能执行对共享数据的操作。 这里涉及到公平锁非公平锁 公平锁 先到先得 先来的线程 先操作 后续线程一次等待 非公平锁 线程要获取锁时 先通过cas抢锁，如果没抢到加入队列中等待下一次抢锁。 Share（共享） ​ 同样的字面意思，多个线程同时执行，这个之后会详细的根据具体的类学习 总结AQS代码很少 ，需要理解的理论知识很多，也是多线程开发中很重要的一环需要多花点时间理解及翻阅资料。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"常用的并发容器的实现和简单理解","slug":"常用的并发容器的实现和简单理解","date":"2022-05-10T11:40:58.000Z","updated":"2022-05-10T12:05:21.357Z","comments":true,"path":"2022/05/10/常用的并发容器的实现和简单理解/","link":"","permalink":"http://example.com/2022/05/10/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/","excerpt":"","text":"ArrayList–&gt;CopyOnWriteArrayListCopyOnWriteArrayList 对一些写操作的实现 123456789101112final ReentrantLock lock = this.lock;lock.lock();try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true;&#125; finally &#123; lock.unlock();&#125; 首先 会复制一份list的复本，然后在复制的list上进行写操作，最后在把旧的list指向copy的副本。 同时这些方法是被加锁的。 读写分离的操作保证了线程的安全性 缺点： 内存占用问题 每次写操作的时候 都会复制一个新的list，这样内存中会有两个对象，如果原list很大占用内存很大，内存的占用直接翻倍，很容易出现YONG GC和Full Gc的情况 数据实时性问题 CopyOnWriteArrayList 只能保证最终的数据一致性，读的时候读的还是add前的就对象，不能保证数据实时性。 HashSet–&gt;&gt;CopyOnWriteArraySet TreeMap–&gt;&gt;ConcurrentSkipListSetCopyOnWriteArraySet和CopyOnWriteArrayList实现的方式差不多不再多说 ConcurrentSkipListSet和ConcurrentSkipListMap有着千丝万缕的关系 之后会详细学这个类 之后再补充 HashMap–&gt;&gt;ConcurrentHashMap Tree–&gt;&gt; ConCurrentSkipListMap明天的学习会重点学习这两个类 这两个类的性能和功能都是非常强大的，实际开发使用也很多。 之后补充。 总结今天的21分钟的网课，我翻阅资料了解相关，理解一些理论知识和打通思路用了一个多少小时。能记录的点不多，但是对之后的学习帮助很大。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"同步容器","slug":"同步容器","date":"2022-05-09T10:20:00.000Z","updated":"2022-05-09T10:39:24.513Z","comments":true,"path":"2022/05/09/同步容器/","link":"","permalink":"http://example.com/2022/05/09/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/","excerpt":"","text":"同步容器 普通同步容器 Vector 和Stack 及 HashTable Collections.Synchronized*** Vector 和HashTable 这些类 就是 Arraylist 和HashMap 这些类的线程较安全版本 并不是完全安全的。 通过对 add put 这些方法加synchronized的锁来保证一定程度的线程安全性 但是当多个线程对同一个同步容器 进行增删操作的时候 同步容器的线程就不安全了（ConcurrentModificationException）会出现这种异常。 当一个线程对一个同步容器执行遍历操作，另一个线程修改了同步容器的集合长度这时候线程就不再安全了。 有了这些缺点就有了并发容器juc（明天开学） 并发容器的优缺点优点：不进行复合操作的时候 同步容器操作简单 使用方便 线程安全 缺点：1. 复合操作时线程不安全 2. 使用了synchronized效率低 3. 快速失败机制 ​ list遍历操作的小知识点在使用 各种list的时候 foreach 和迭代器遍历的时候，如果进行remove操作会直接报错 在for循环中则不会 前两种建议先标识出来循环结束后再做处理 总结同步容器的作用微乎其微 ，实际开发中应该也很少使用，效率问题的同时线程并不是完全安全的。不用也罢！ 作为知识储备看看理论得了。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"常见线程不安全类和写法","slug":"常见线程不安全类和写法","date":"2022-05-08T02:14:43.000Z","updated":"2022-05-08T02:53:18.373Z","comments":true,"path":"2022/05/08/常见线程不安全类和写法/","link":"","permalink":"http://example.com/2022/05/08/%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%B1%BB%E5%92%8C%E5%86%99%E6%B3%95/","excerpt":"","text":"前言平时开发中 在写方法的时候 大多是都是在一个方法中 new 出一个类的新的对象 其实这种写法叫做堆栈封闭 保证了线程的安全性 字符串拼接 StringBuilder和StringBuffer首先 StringBuilder 是线程不安全的 StringBuffer 是线程安全的 主要看他们append的方法实现就很好理解 12345678910111213StringBuffer 的append @Override public synchronized StringBuffer append(int i) &#123; toStringCache = null; super.append(i); return this; &#125;StringBuilder 的append 实现 @Override public StringBuilder append(int i) &#123; super.append(i); return this; &#125; StringBuffer 通过在append 方法上 加synchronized锁的方式 保证了线程的安全性 相应的牺牲了效率 不考虑线程安全性的情况下 尽量使用builder 时间相关SimpleDateFormat和joda-time直接看多线程下SimpleDateFormat类运行的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 public static int clientTotal=5000; public static int ThteadTotal=200; private final static SimpleDateFormat sim=new SimpleDateFormat(&quot;yyyyMMdd&quot;); public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore=new Semaphore(ThteadTotal); final CountDownLatch countDownLatch=new CountDownLatch(clientTotal); for (int i=1;i&lt;=clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire(); //争抢方法 update(); //释放 semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125;); &#125; &#125; private static void update()&#123; try &#123; Date parse = sim.parse(&quot;20220508&quot;); log.info(&quot;12312312123&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;结果：java.lang.NumberFormatException: For input string: &quot;&quot; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:601) at java.lang.Long.parseLong(Long.java:631) at java.text.DigitList.getLong(DigitList.java:195) at java.text.DecimalFormat.parse(DecimalFormat.java:2082) at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1867) at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) at java.text.DateFormat.parse(DateFormat.java:364) at com.imooc.concurrency.example.NotThreadSafeExampleClass.TimeExample.update(TimeExample.java:49) at com.imooc.concurrency.example.NotThreadSafeExampleClass.TimeExample.lambda$main$0(TimeExample.java:33) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)java.lang.NumberFormatException: For input string: &quot;&quot; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:601) at java.lang.Long.parseLong(Long.java:631) at java.text.DigitList.getLong(DigitList.java:195) at java.text.DecimalFormat.parse(DecimalFormat.java:2082) at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1867) at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) at java.text.DateFormat.parse(DateFormat.java:364) at com.imooc.concurrency.example.NotThreadSafeExampleClass.TimeExample.update(TimeExample.java:49) at com.imooc.concurrency.example.NotThreadSafeExampleClass.TimeExample.lambda$main$0(TimeExample.java:33) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) 多线程的情况下 调用SimpleDateFormat的parse方法会疯狂报错 证明了他的线程不安全性 换一种写法 123456789101112private static void update()&#123; //在这里新建 SimpleDateFormat sim=new SimpleDateFormat(&quot;yyyyMMdd&quot;); try &#123; Date parse = sim.parse(&quot;20220508&quot;); log.info(&quot;12312312123&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 这种是我们常用写法 高大上一点就叫堆栈封闭 joda-time是线程安全的类 并且处理时间格式的效率是比SimpleDateFormat快的 java8之后还提供了一些时间类DateTimeFormatter 等 之后平时多用用这些类 集合类这里先简单记录一下 arraylist hashset hashmap 这三个类都是线程不安全的类 并且有多个对应线程安全的类 以后会单独写一篇 线程不安全的写法1if(xxx)&#123;xxx&#125; 先判断在执行这种操作 if中的对象只要是会被其他线程共享的对象 就会出现线程不安全的问题 开发中先判断if中的要被判断的参数或对象会不会被其他线程影响 然后考虑加锁 才能保证线程的安全性。 今日总结无 愉快的周末开始了。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"ThreadLocal和线程封闭","slug":"ThreadLocal和线程封闭","date":"2022-05-07T09:48:34.000Z","updated":"2022-05-07T10:16:26.175Z","comments":true,"path":"2022/05/07/ThreadLocal和线程封闭/","link":"","permalink":"http://example.com/2022/05/07/ThreadLocal%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/","excerpt":"","text":"线程封闭当访问共享变量时，往往需要加锁来保证数据同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了。这种技术称为线程封闭。在Java语言中，提供了一些类库和机制来维护线程的封闭性，例如局部变量和ThreadLocal类 Ad-hoc 线程封闭程序控制实现，比较脆弱，尽量少用 堆栈封闭：局部变量，无并发问题，在项目中使用最多，简单说就是局部变量，方法的变量都拷贝到线程的堆栈中，只有这个线程能访问到。尽量少使用全局变量（变量不是常量）（平时写接口大部分都是这种方式，都是局部变量） ThreadLocal线程封闭：比较好的封闭方法 ThreadLocal（线程变量）类threadLocal 类简单理解就是，threadLocal中存入的变量只有当前线程可以存取，对于其他线程来说是隔离的，ThreadLocal为每个变量都创建了一个副本，每个变量访问自己变量的副本。 ThreadLocal的简单使用1234567891011121314151617181920212223242526272829303132333435363738394041424344 public final static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void add(Long id)&#123; threadLocal.set(id); &#125; public static Long get()&#123; return threadLocal.get(); &#125; public static void remove()&#123; threadLocal.remove(); &#125;使用很简单主要看关键方法的实现 get实现 public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; set实现 public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 可以看到每次getset都是会先获取当前线程 存储关键的ThreadLocalMap 也都是对当前线程进行的存取操作 保证了存储的数据对于每个线程的独立性 ThreadLocal使用场景 每个线程需要有自己单独的实例 有个实例需要在多个方法中使用并且不想被多线程所共享 ​ 举个栗子： 登录的用户信息 经常会被很多方法中取用 需要进行很多次参数传递 从controller 到service中再到各个方法 如果用threadLocal 可以在任何地方调用get方法取得 还能保证不出现线程不安全的情况。 总结今天就没什么总结 看了一节课没看懂 又看了好多帖子 才有个一知半解； threadLocal经常配合filter和interceptor使用 学习的时候我发现很久没写这个两个东西 把这两个东西的使用也顺便复习了 今天收获颇丰","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"不可变对象","slug":"不可变对象","date":"2022-05-06T10:25:55.000Z","updated":"2022-05-06T10:27:39.608Z","comments":true,"path":"2022/05/06/不可变对象/","link":"","permalink":"http://example.com/2022/05/06/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"不可变对象不可变对象需要满足的条件 对象创建后状态不能修改 对象所有域都是final类型 对象是正确创建的（对象创建期间，this引用没有逸出）（完全没理解这是啥意思） 关键字final final 修饰类 类不能被继承 final 修饰方法 1.锁定的方法不能被继承类重写修改 2. 效率（早期会提升效率最近版本已经没用了） final 修饰变量 基本数据的变量修饰后不能被修改 ， 引用类被修饰后不能指向新的对象 主要注意修饰引用类的时候 是可以修改类中变量的数值 例修饰map 1234//可以进行的操作map.put(1,2) //不可以进行的操作 map=Maps.newHashMap(); 不使用final定义不可变对象1. Collections.unmodifiable***例map 123456789101112131415161718192021222324252627282930313233public class FinalExample &#123;// private final static Integer aaa=0;// private final static String q=&quot;&quot;; private static Map&lt;Integer,Integer&gt; map = Maps.newHashMap(); public static void main(String[] args) &#123;// q=&quot;&quot;;// aaa=1; Map&lt;Integer, Integer&gt; integerIntegerMap = Collections.unmodifiableMap(map); integerIntegerMap.put(1,2); &#125;&#125;运行结果：Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1459) at com.imooc.concurrency.example.immutable.FinalExample.main(FinalExample.java:18) 翻看unmodifiableMap源码看到他的put方法的实现 public V put(K key, V value) &#123; throw new UnsupportedOperationException(); &#125; 不光是put 所有能修改的map中值的方法都被直接抛出异常 2. google guava 包提供的immutable***12345678910111213141516171819202122 private static ImmutableList list= ImmutableList.of(1,2,3,4); public static void main(String[] args) &#123; list.add(123);//这里的add方法会有横线表示为不推荐使用 &#125;运行结果：Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at com.google.common.collect.ImmutableCollection.add(ImmutableCollection.java:220) at com.imooc.concurrency.example.immutable.FinalExample.main(FinalExample.java:24) add方法的实现 @Deprecated @CanIgnoreReturnValue public final boolean add(E e) &#123; throw new UnsupportedOperationException(); &#125; 两种方法的对于put add这些方法的实现 很相似 都是直接抛出异常 ​ ​ 总结多线程开发中如果对象条件允许设置为不可变对象，尽量把对象设置为不可变对象，避免出现线程安全问题","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"单例模式和线程安全的关系","slug":"单例模式和线程安全的关系","date":"2022-03-01T07:29:45.000Z","updated":"2022-03-01T08:39:02.891Z","comments":true,"path":"2022/03/01/单例模式和线程安全的关系/","link":"","permalink":"http://example.com/2022/03/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"","text":"懒汉式和饿汉式懒汉式123456789101112131415161718@NotThreadSafe@NotRecommend//懒汉模式public class SingletonExample1 &#123; private SingletonExample1() &#123; &#125; private static SingletonExample1 ins=null; public static SingletonExample1 getIns()&#123; if (ins==null)&#123; ins = new SingletonExample1(); &#125; return ins; &#125;&#125; 优点 在需要时调用才开始创建对象 性能比饿汉式优秀 缺点 线程不安全 饿汉式123456789101112131415161718192021222324252627282930313233343536373839404142/** * 饿汉式 1 */@ThreadSafepublic class SingletonExample2 &#123; private SingletonExample2() &#123; &#125; private static SingletonExample2 ins=new SingletonExample2(); public SingletonExample2 getIns()&#123; return ins; &#125;&#125;/** * 饿汉式2 */@ThreadSafepublic class SingletonExample3 &#123; private SingletonExample3() &#123; &#125; private static SingletonExample3 ins=null; static &#123; ins=new SingletonExample3(); &#125; public static SingletonExample3 getIns()&#123; return ins; &#125;&#125; 优点 线程安全 缺点 类加载就会创建对象，如果后续代码没有使用造成性能浪费，如果构造方法中需要处理的代码很多 会有性能问题 如何使懒汉式性能安全synchronized修饰方法12345678910111213141516@ThreadSafe@NotRecommendpublic class SingletonExample4 &#123; private SingletonExample4() &#123; &#125; private static SingletonExample4 ins=null; //性能问题 不推荐写法。 public static synchronized SingletonExample4 getIns()&#123; if (ins==null)&#123; ins = new SingletonExample4(); &#125; return ins; &#125;&#125; 用synchronized修饰 类的获取方法 保证了线程安全 但是降低了性能 双重同步锁123456789101112131415161718192021222324252627282930@NotThreadSafe@NotRecommend/** * 双重同步锁单例模式 懒汉模式 */public class SingletonExample5 &#123; private SingletonExample5() &#123; &#125; //private static SingletonExample5 ins=null; private volatile static SingletonExample5 ins=null; public static SingletonExample5 getIns()&#123; if (ins==null)&#123; synchronized (SingletonExample5.class)&#123; if (ins==null)&#123; ins = new SingletonExample5(); //线程不安全的，主要原因是cpu和jvm会对指令重排，多线程的情况下有可能获得未被初始化的对象 //解决办法就是静止指令重排 volatile &#125; &#125; &#125; return ins; &#125; 不使用 volatile修饰的情况下 双重同步锁单例模式也是线程不安全的，指令重排会使别的线程获取到未被初始化的对象。volatile禁止指令重排，这种写法比直接用synchronized修饰方法性能高并且保证了线程的安全性 枚举单例模式（推荐写法）123456789101112131415161718192021222324252627282930313233343536373839/** * 枚举单例模式 最安全的 */@ThreadSafe@Recommend//枚举单例模式public class SingletonExample7 &#123; private SingletonExample7()&#123; &#125; public static SingletonExample7 getInstance ()&#123; return SingletonExample7Enum.instance.getIntance(); &#125; private enum SingletonExample7Enum&#123; instance; private SingletonExample7 singletonExample7; //jvm保证绝对只执行一次 SingletonExample7Enum()&#123; singletonExample7=new SingletonExample7(); &#125; public SingletonExample7 getIntance()&#123; return singletonExample7; &#125; &#125; &#125; 枚举实现单例 使用的时候才会创建对象不会有饿汉式的性能浪费等问题，而且保证了性能安全。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"synchronizd","slug":"synchronizd","date":"2022-02-19T02:30:53.000Z","updated":"2022-02-19T03:08:33.350Z","comments":true,"path":"2022/02/19/synchronizd/","link":"","permalink":"http://example.com/2022/02/19/synchronizd/","excerpt":"","text":"Synchronizdsynchronizd的四种用法和作用范围 修饰代码块，大括号括起来的代码，作用于调用的那个对象 修饰方法，整个方法，作用于调用的对象 修饰静态方法，整个静态方法，作用于所有对象 修饰类 括号括起来的部分，作用于所有对象 演示，作用于方法和代码块修饰代码块 和修饰方法12345678910111213141516171819202122232425262728293031323334353637383940414243 public void test1(String name)&#123; //synchronized 修饰一个代码块 synchronized (this)&#123; for (int i=0;i&lt;10;i++)&#123; log.info(&quot;test1 - &#123;&#125; - &#123;&#125;&quot;,name,i); &#125; &#125; &#125; //synchronized 修饰一个方法 public synchronized void test2(String name)&#123; for (int i=0;i&lt;10;i++)&#123; log.info(&quot;test2 - &#123;&#125; - &#123;&#125;&quot;,name,i); &#125; &#125;//test1的测试 public static void main(String[] args) &#123; SynchronizedExample1 example1 = new SynchronizedExample1(); SynchronizedExample1 example2 = new SynchronizedExample1(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt;&#123; example1.test1(&quot;example1&quot;); &#125;); executorService.execute(()-&gt;&#123; example1.test1(&quot;example2&quot;); &#125;); &#125;//test2 的测试 public static void main(String[] args) &#123; SynchronizedExample1 example1 = new SynchronizedExample1(); SynchronizedExample1 example2 = new SynchronizedExample1(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt;&#123; example1.test2(&quot;example1&quot;); &#125;); executorService.execute(()-&gt;&#123; example2.test2(&quot;example2&quot;); &#125;); &#125; test1的结果（同一对象不同线程调用）12345678910111213141516171819202110:58:16.720 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 010:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 110:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 210:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 310:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 410:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 510:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 610:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 710:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 810:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 910:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 010:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 110:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 210:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 310:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 410:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 510:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 610:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 710:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 810:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 9 可以看到ex2 需要等ex1执行结束之后才开始执行 说明synchroized生效了 test2运行结果（不同线程不同对象）12345678910111213141516171819202111:01:31.114 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 011:01:31.114 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 011:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 111:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 111:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 211:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 311:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 211:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 311:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 411:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 511:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 411:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 611:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 511:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 711:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 611:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 811:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 711:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 911:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 811:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 9 ex1 和 ex2 交替运行 说明 修饰方法和代码块时 只对调用方法和代码块的那个对象有效 修饰静态方法和类123456789101112131415161718192021222324252627282930313233343536373839404142434445 //synchronized 修饰一个类 public void test1(String name) &#123; synchronized (SynchronizedExample2.class)&#123; for (int i=0;i&lt;10;i++)&#123; log.info(&quot;test1 - &#123;&#125; - &#123;&#125;&quot;,name,i); &#125; &#125; &#125; //synchronized 修饰一个静态方法 public static synchronized void test2(String name)&#123; for (int i=0;i&lt;10;i++)&#123; log.info(&quot;test2 - &#123;&#125; - &#123;&#125;&quot;,name,i); &#125; &#125;//test1 public static void main(String[] args) &#123; SynchronizedExample2 example1 = new SynchronizedExample2(); SynchronizedExample2 example2 = new SynchronizedExample2(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt;&#123; example1.test1(&quot;example1&quot;); &#125;); executorService.execute(()-&gt;&#123; example1.test1(&quot;example2&quot;); &#125;); &#125; public static void main(String[] args) &#123; SynchronizedExample2 example1 = new SynchronizedExample2(); SynchronizedExample2 example2 = new SynchronizedExample2(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt;&#123; example1.test1(&quot;example1&quot;); &#125;); executorService.execute(()-&gt;&#123; example2.test1(&quot;example2&quot;); &#125;); &#125; test1结果（同对象不同线程）12345678910111213141516171819202111:05:44.398 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 011:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 111:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 211:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 311:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 411:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 511:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 611:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 711:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 811:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 911:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 011:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 111:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 211:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 311:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 411:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 511:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 611:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 711:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 811:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 9 生效 没什么可说的 test2（不同对象不同线程）123456789101112131415161718192011:06:51.939 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 011:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 111:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 211:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 311:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 411:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 511:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 611:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 711:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 811:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 911:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 011:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 111:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 211:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 311:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 411:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 511:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 611:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 711:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 811:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 9 可以看到修饰类和方法的时候 不同的对象和不同的线程 ex1 和ex2 依旧保持顺序执行 ex1执行完后ex2开始执行，由此可得 在synchronized修饰类和静态方法时 对这个类的所有对象都生效","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"CAS(ConmpareAndSwap)","slug":"CAS-ConmpareAndSwap","date":"2022-02-18T06:59:30.000Z","updated":"2022-02-18T07:25:28.001Z","comments":true,"path":"2022/02/18/CAS-ConmpareAndSwap/","link":"","permalink":"http://example.com/2022/02/18/CAS-ConmpareAndSwap/","excerpt":"","text":"简介（网络摘录）​ 在计算机科学中，比较和交换（Conmpare And Swap）是用于实现多线程同步的原子指令。它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果该值在同一时间被另一个线程更新，则写入将失败。操作结果必须说明是否进行替换; 这可以通过一个简单的布尔响应（这个变体通常称为比较和设置），或通过返回从内存位置读取的值来完成。 ​ CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” ​ 通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。 ​ 类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。 CAS的问题 ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 关于ABA问题参考文档: http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html 2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j&#x3D;a，合并一下ij&#x3D;2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 Java中CAS的实现（学习总结）atomic说到java中的cas不得不提atomic 以atomic中的AtomicInteger中的incrementAndGet方法为例 123456789101112131415public final int incrementAndGet() &#123;return unsafe.getAndAddInt(this, valueOffset, 1) + 1; &#125; public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125; 主要看unsafe的getAndAddInt方法的实现 var1 为当前atomicInteger var2为当前值 var5为底层值 var4为更新量 可以看到循环 会不停的从底层取出最新的var5和var2对比 当 var5&#x3D;var2时 才会执行更新操作var5+var4 保证了原子性 如何解决cas的aba问题atomic中AtomicStampedReference 解决了这个问题 为每一步修改操作加上版本号，比如原数据为0 版本号为0 一个线程修改原数据为1 后 版本号也为1 再把原数据修改成0 版本号却变成了2 另一个线程通过cas对比后虽然数据还是0但是版本号已经改变了 这样就避免了aba问题","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程","slug":"多线程","date":"2022-02-16T09:10:39.000Z","updated":"2022-02-16T09:12:37.960Z","comments":true,"path":"2022/02/16/多线程/","link":"","permalink":"http://example.com/2022/02/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"新博客的第一篇文章","slug":"新博客的第一篇文章","date":"2022-02-16T09:03:32.000Z","updated":"2022-02-16T09:07:03.507Z","comments":true,"path":"2022/02/16/新博客的第一篇文章/","link":"","permalink":"http://example.com/2022/02/16/%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"​ 很久没写作了，工作中很多有用的没有积累下来，之前的博客由于服务器的到期数据没留下来 新开一个博客放在自己的电脑上重新维护，2022年新的开始，加油。 希望每次我偷懒的时候看到这篇文章都可以想到写这篇文章时候下的决心。 ​ 2022.02.16","categories":[{"name":"new","slug":"new","permalink":"http://example.com/categories/new/"}],"tags":[{"name":"新的开始","slug":"新的开始","permalink":"http://example.com/tags/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"}]},{"title":"aaa","slug":"aaa","date":"2022-02-16T07:32:35.000Z","updated":"2022-02-16T08:50:49.313Z","comments":true,"path":"2022/02/16/aaa/","link":"","permalink":"http://example.com/2022/02/16/aaa/","excerpt":"","text":"","categories":[{"name":"suibianxiexie","slug":"suibianxiexie","permalink":"http://example.com/categories/suibianxiexie/"}],"tags":[{"name":"第一篇文章","slug":"第一篇文章","permalink":"http://example.com/tags/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-02-16T06:53:03.240Z","updated":"2022-02-16T06:53:03.240Z","comments":true,"path":"2022/02/16/hello-world/","link":"","permalink":"http://example.com/2022/02/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"new","slug":"new","permalink":"http://example.com/categories/new/"},{"name":"suibianxiexie","slug":"suibianxiexie","permalink":"http://example.com/categories/suibianxiexie/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"新的开始","slug":"新的开始","permalink":"http://example.com/tags/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"},{"name":"第一篇文章","slug":"第一篇文章","permalink":"http://example.com/tags/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"}]}