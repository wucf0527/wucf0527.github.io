{"meta":{"title":"wcf","subtitle":"无","description":"无","author":"wucf","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2022-02-16T07:21:43.000Z","updated":"2022-02-16T08:23:40.226Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-02-16T07:21:48.000Z","updated":"2022-02-16T08:25:01.777Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"常见线程不安全类和写法","slug":"常见线程不安全类和写法","date":"2022-05-08T02:14:43.000Z","updated":"2022-05-08T02:53:18.373Z","comments":true,"path":"2022/05/08/常见线程不安全类和写法/","link":"","permalink":"http://example.com/2022/05/08/%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%B1%BB%E5%92%8C%E5%86%99%E6%B3%95/","excerpt":"","text":"前言平时开发中 在写方法的时候 大多是都是在一个方法中 new 出一个类的新的对象 其实这种写法叫做堆栈封闭 保证了线程的安全性 字符串拼接 StringBuilder和StringBuffer首先 StringBuilder 是线程不安全的 StringBuffer 是线程安全的 主要看他们append的方法实现就很好理解 12345678910111213StringBuffer 的append @Override public synchronized StringBuffer append(int i) &#123; toStringCache = null; super.append(i); return this; &#125;StringBuilder 的append 实现 @Override public StringBuilder append(int i) &#123; super.append(i); return this; &#125; StringBuffer 通过在append 方法上 加synchronized锁的方式 保证了线程的安全性 相应的牺牲了效率 不考虑线程安全性的情况下 尽量使用builder 时间相关SimpleDateFormat和joda-time直接看多线程下SimpleDateFormat类运行的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 public static int clientTotal=5000; public static int ThteadTotal=200; private final static SimpleDateFormat sim=new SimpleDateFormat(&quot;yyyyMMdd&quot;); public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore=new Semaphore(ThteadTotal); final CountDownLatch countDownLatch=new CountDownLatch(clientTotal); for (int i=1;i&lt;=clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire(); //争抢方法 update(); //释放 semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125;); &#125; &#125; private static void update()&#123; try &#123; Date parse = sim.parse(&quot;20220508&quot;); log.info(&quot;12312312123&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;结果：java.lang.NumberFormatException: For input string: &quot;&quot; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:601) at java.lang.Long.parseLong(Long.java:631) at java.text.DigitList.getLong(DigitList.java:195) at java.text.DecimalFormat.parse(DecimalFormat.java:2082) at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1867) at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) at java.text.DateFormat.parse(DateFormat.java:364) at com.imooc.concurrency.example.NotThreadSafeExampleClass.TimeExample.update(TimeExample.java:49) at com.imooc.concurrency.example.NotThreadSafeExampleClass.TimeExample.lambda$main$0(TimeExample.java:33) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)java.lang.NumberFormatException: For input string: &quot;&quot; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:601) at java.lang.Long.parseLong(Long.java:631) at java.text.DigitList.getLong(DigitList.java:195) at java.text.DecimalFormat.parse(DecimalFormat.java:2082) at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1867) at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) at java.text.DateFormat.parse(DateFormat.java:364) at com.imooc.concurrency.example.NotThreadSafeExampleClass.TimeExample.update(TimeExample.java:49) at com.imooc.concurrency.example.NotThreadSafeExampleClass.TimeExample.lambda$main$0(TimeExample.java:33) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) 多线程的情况下 调用SimpleDateFormat的parse方法会疯狂报错 证明了他的线程不安全性 换一种写法 123456789101112private static void update()&#123; //在这里新建 SimpleDateFormat sim=new SimpleDateFormat(&quot;yyyyMMdd&quot;); try &#123; Date parse = sim.parse(&quot;20220508&quot;); log.info(&quot;12312312123&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 这种是我们常用写法 高大上一点就叫堆栈封闭 joda-time是线程安全的类 并且处理时间格式的效率是比SimpleDateFormat快的 java8之后还提供了一些时间类DateTimeFormatter 等 之后平时多用用这些类 集合类这里先简单记录一下 arraylist hashset hashmap 这三个类都是线程不安全的类 并且有多个对应线程安全的类 以后会单独写一篇 线程不安全的写法1if(xxx)&#123;xxx&#125; 先判断在执行这种操作 if中的对象只要是会被其他线程共享的对象 就会出现线程不安全的问题 开发中先判断if中的要被判断的参数或对象会不会被其他线程影响 然后考虑加锁 才能保证线程的安全性。 今日总结无 愉快的周末开始了。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"ThreadLocal和线程封闭","slug":"ThreadLocal和线程封闭","date":"2022-05-07T09:48:34.000Z","updated":"2022-05-07T10:16:26.175Z","comments":true,"path":"2022/05/07/ThreadLocal和线程封闭/","link":"","permalink":"http://example.com/2022/05/07/ThreadLocal%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/","excerpt":"","text":"线程封闭当访问共享变量时，往往需要加锁来保证数据同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了。这种技术称为线程封闭。在Java语言中，提供了一些类库和机制来维护线程的封闭性，例如局部变量和ThreadLocal类 Ad-hoc 线程封闭程序控制实现，比较脆弱，尽量少用 堆栈封闭：局部变量，无并发问题，在项目中使用最多，简单说就是局部变量，方法的变量都拷贝到线程的堆栈中，只有这个线程能访问到。尽量少使用全局变量（变量不是常量）（平时写接口大部分都是这种方式，都是局部变量） ThreadLocal线程封闭：比较好的封闭方法 ThreadLocal（线程变量）类threadLocal 类简单理解就是，threadLocal中存入的变量只有当前线程可以存取，对于其他线程来说是隔离的，ThreadLocal为每个变量都创建了一个副本，每个变量访问自己变量的副本。 ThreadLocal的简单使用1234567891011121314151617181920212223242526272829303132333435363738394041424344 public final static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void add(Long id)&#123; threadLocal.set(id); &#125; public static Long get()&#123; return threadLocal.get(); &#125; public static void remove()&#123; threadLocal.remove(); &#125;使用很简单主要看关键方法的实现 get实现 public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; set实现 public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 可以看到每次getset都是会先获取当前线程 存储关键的ThreadLocalMap 也都是对当前线程进行的存取操作 保证了存储的数据对于每个线程的独立性 ThreadLocal使用场景 每个线程需要有自己单独的实例 有个实例需要在多个方法中使用并且不想被多线程所共享 ​ 举个栗子： 登录的用户信息 经常会被很多方法中取用 需要进行很多次参数传递 从controller 到service中再到各个方法 如果用threadLocal 可以在任何地方调用get方法取得 还能保证不出现线程不安全的情况。 总结今天就没什么总结 看了一节课没看懂 又看了好多帖子 才有个一知半解； threadLocal经常配合filter和interceptor使用 学习的时候我发现很久没写这个两个东西 把这两个东西的使用也顺便复习了 今天收获颇丰","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"不可变对象","slug":"不可变对象","date":"2022-05-06T10:25:55.000Z","updated":"2022-05-06T10:27:39.608Z","comments":true,"path":"2022/05/06/不可变对象/","link":"","permalink":"http://example.com/2022/05/06/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"不可变对象不可变对象需要满足的条件 对象创建后状态不能修改 对象所有域都是final类型 对象是正确创建的（对象创建期间，this引用没有逸出）（完全没理解这是啥意思） 关键字final final 修饰类 类不能被继承 final 修饰方法 1.锁定的方法不能被继承类重写修改 2. 效率（早期会提升效率最近版本已经没用了） final 修饰变量 基本数据的变量修饰后不能被修改 ， 引用类被修饰后不能指向新的对象 主要注意修饰引用类的时候 是可以修改类中变量的数值 例修饰map 1234//可以进行的操作map.put(1,2) //不可以进行的操作 map=Maps.newHashMap(); 不使用final定义不可变对象1. Collections.unmodifiable***例map 123456789101112131415161718192021222324252627282930313233public class FinalExample &#123;// private final static Integer aaa=0;// private final static String q=&quot;&quot;; private static Map&lt;Integer,Integer&gt; map = Maps.newHashMap(); public static void main(String[] args) &#123;// q=&quot;&quot;;// aaa=1; Map&lt;Integer, Integer&gt; integerIntegerMap = Collections.unmodifiableMap(map); integerIntegerMap.put(1,2); &#125;&#125;运行结果：Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1459) at com.imooc.concurrency.example.immutable.FinalExample.main(FinalExample.java:18) 翻看unmodifiableMap源码看到他的put方法的实现 public V put(K key, V value) &#123; throw new UnsupportedOperationException(); &#125; 不光是put 所有能修改的map中值的方法都被直接抛出异常 2. google guava 包提供的immutable***12345678910111213141516171819202122 private static ImmutableList list= ImmutableList.of(1,2,3,4); public static void main(String[] args) &#123; list.add(123);//这里的add方法会有横线表示为不推荐使用 &#125;运行结果：Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at com.google.common.collect.ImmutableCollection.add(ImmutableCollection.java:220) at com.imooc.concurrency.example.immutable.FinalExample.main(FinalExample.java:24) add方法的实现 @Deprecated @CanIgnoreReturnValue public final boolean add(E e) &#123; throw new UnsupportedOperationException(); &#125; 两种方法的对于put add这些方法的实现 很相似 都是直接抛出异常 ​ ​ 总结多线程开发中如果对象条件允许设置为不可变对象，尽量把对象设置为不可变对象，避免出现线程安全问题","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"单例模式和线程安全的关系","slug":"单例模式和线程安全的关系","date":"2022-03-01T07:29:45.000Z","updated":"2022-03-01T08:39:02.891Z","comments":true,"path":"2022/03/01/单例模式和线程安全的关系/","link":"","permalink":"http://example.com/2022/03/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"","text":"懒汉式和饿汉式懒汉式123456789101112131415161718@NotThreadSafe@NotRecommend//懒汉模式public class SingletonExample1 &#123; private SingletonExample1() &#123; &#125; private static SingletonExample1 ins=null; public static SingletonExample1 getIns()&#123; if (ins==null)&#123; ins = new SingletonExample1(); &#125; return ins; &#125;&#125; 优点 在需要时调用才开始创建对象 性能比饿汉式优秀 缺点 线程不安全 饿汉式123456789101112131415161718192021222324252627282930313233343536373839404142/** * 饿汉式 1 */@ThreadSafepublic class SingletonExample2 &#123; private SingletonExample2() &#123; &#125; private static SingletonExample2 ins=new SingletonExample2(); public SingletonExample2 getIns()&#123; return ins; &#125;&#125;/** * 饿汉式2 */@ThreadSafepublic class SingletonExample3 &#123; private SingletonExample3() &#123; &#125; private static SingletonExample3 ins=null; static &#123; ins=new SingletonExample3(); &#125; public static SingletonExample3 getIns()&#123; return ins; &#125;&#125; 优点 线程安全 缺点 类加载就会创建对象，如果后续代码没有使用造成性能浪费，如果构造方法中需要处理的代码很多 会有性能问题 如何使懒汉式性能安全synchronized修饰方法12345678910111213141516@ThreadSafe@NotRecommendpublic class SingletonExample4 &#123; private SingletonExample4() &#123; &#125; private static SingletonExample4 ins=null; //性能问题 不推荐写法。 public static synchronized SingletonExample4 getIns()&#123; if (ins==null)&#123; ins = new SingletonExample4(); &#125; return ins; &#125;&#125; 用synchronized修饰 类的获取方法 保证了线程安全 但是降低了性能 双重同步锁123456789101112131415161718192021222324252627282930@NotThreadSafe@NotRecommend/** * 双重同步锁单例模式 懒汉模式 */public class SingletonExample5 &#123; private SingletonExample5() &#123; &#125; //private static SingletonExample5 ins=null; private volatile static SingletonExample5 ins=null; public static SingletonExample5 getIns()&#123; if (ins==null)&#123; synchronized (SingletonExample5.class)&#123; if (ins==null)&#123; ins = new SingletonExample5(); //线程不安全的，主要原因是cpu和jvm会对指令重排，多线程的情况下有可能获得未被初始化的对象 //解决办法就是静止指令重排 volatile &#125; &#125; &#125; return ins; &#125; 不使用 volatile修饰的情况下 双重同步锁单例模式也是线程不安全的，指令重排会使别的线程获取到未被初始化的对象。volatile禁止指令重排，这种写法比直接用synchronized修饰方法性能高并且保证了线程的安全性 枚举单例模式（推荐写法）123456789101112131415161718192021222324252627282930313233343536373839/** * 枚举单例模式 最安全的 */@ThreadSafe@Recommend//枚举单例模式public class SingletonExample7 &#123; private SingletonExample7()&#123; &#125; public static SingletonExample7 getInstance ()&#123; return SingletonExample7Enum.instance.getIntance(); &#125; private enum SingletonExample7Enum&#123; instance; private SingletonExample7 singletonExample7; //jvm保证绝对只执行一次 SingletonExample7Enum()&#123; singletonExample7=new SingletonExample7(); &#125; public SingletonExample7 getIntance()&#123; return singletonExample7; &#125; &#125; &#125; 枚举实现单例 使用的时候才会创建对象不会有饿汉式的性能浪费等问题，而且保证了性能安全。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"synchronizd","slug":"synchronizd","date":"2022-02-19T02:30:53.000Z","updated":"2022-02-19T03:08:33.350Z","comments":true,"path":"2022/02/19/synchronizd/","link":"","permalink":"http://example.com/2022/02/19/synchronizd/","excerpt":"","text":"Synchronizdsynchronizd的四种用法和作用范围 修饰代码块，大括号括起来的代码，作用于调用的那个对象 修饰方法，整个方法，作用于调用的对象 修饰静态方法，整个静态方法，作用于所有对象 修饰类 括号括起来的部分，作用于所有对象 演示，作用于方法和代码块修饰代码块 和修饰方法12345678910111213141516171819202122232425262728293031323334353637383940414243 public void test1(String name)&#123; //synchronized 修饰一个代码块 synchronized (this)&#123; for (int i=0;i&lt;10;i++)&#123; log.info(&quot;test1 - &#123;&#125; - &#123;&#125;&quot;,name,i); &#125; &#125; &#125; //synchronized 修饰一个方法 public synchronized void test2(String name)&#123; for (int i=0;i&lt;10;i++)&#123; log.info(&quot;test2 - &#123;&#125; - &#123;&#125;&quot;,name,i); &#125; &#125;//test1的测试 public static void main(String[] args) &#123; SynchronizedExample1 example1 = new SynchronizedExample1(); SynchronizedExample1 example2 = new SynchronizedExample1(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt;&#123; example1.test1(&quot;example1&quot;); &#125;); executorService.execute(()-&gt;&#123; example1.test1(&quot;example2&quot;); &#125;); &#125;//test2 的测试 public static void main(String[] args) &#123; SynchronizedExample1 example1 = new SynchronizedExample1(); SynchronizedExample1 example2 = new SynchronizedExample1(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt;&#123; example1.test2(&quot;example1&quot;); &#125;); executorService.execute(()-&gt;&#123; example2.test2(&quot;example2&quot;); &#125;); &#125; test1的结果（同一对象不同线程调用）12345678910111213141516171819202110:58:16.720 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 010:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 110:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 210:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 310:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 410:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 510:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 610:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 710:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 810:58:16.723 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 910:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 010:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 110:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 210:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 310:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 410:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 510:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 610:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 710:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 810:58:16.723 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 9 可以看到ex2 需要等ex1执行结束之后才开始执行 说明synchroized生效了 test2运行结果（不同线程不同对象）12345678910111213141516171819202111:01:31.114 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 011:01:31.114 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 011:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 111:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 111:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 211:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 311:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 211:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 311:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 411:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 511:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 411:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 611:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 511:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 711:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 611:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 811:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 711:01:31.117 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example2 - 911:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 811:01:31.117 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample1 - test1 - example1 - 9 ex1 和 ex2 交替运行 说明 修饰方法和代码块时 只对调用方法和代码块的那个对象有效 修饰静态方法和类123456789101112131415161718192021222324252627282930313233343536373839404142434445 //synchronized 修饰一个类 public void test1(String name) &#123; synchronized (SynchronizedExample2.class)&#123; for (int i=0;i&lt;10;i++)&#123; log.info(&quot;test1 - &#123;&#125; - &#123;&#125;&quot;,name,i); &#125; &#125; &#125; //synchronized 修饰一个静态方法 public static synchronized void test2(String name)&#123; for (int i=0;i&lt;10;i++)&#123; log.info(&quot;test2 - &#123;&#125; - &#123;&#125;&quot;,name,i); &#125; &#125;//test1 public static void main(String[] args) &#123; SynchronizedExample2 example1 = new SynchronizedExample2(); SynchronizedExample2 example2 = new SynchronizedExample2(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt;&#123; example1.test1(&quot;example1&quot;); &#125;); executorService.execute(()-&gt;&#123; example1.test1(&quot;example2&quot;); &#125;); &#125; public static void main(String[] args) &#123; SynchronizedExample2 example1 = new SynchronizedExample2(); SynchronizedExample2 example2 = new SynchronizedExample2(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt;&#123; example1.test1(&quot;example1&quot;); &#125;); executorService.execute(()-&gt;&#123; example2.test1(&quot;example2&quot;); &#125;); &#125; test1结果（同对象不同线程）12345678910111213141516171819202111:05:44.398 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 011:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 111:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 211:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 311:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 411:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 511:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 611:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 711:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 811:05:44.401 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 911:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 011:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 111:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 211:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 311:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 411:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 511:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 611:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 711:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 811:05:44.401 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example2 - 9 生效 没什么可说的 test2（不同对象不同线程）123456789101112131415161718192011:06:51.939 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 011:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 111:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 211:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 311:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 411:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 511:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 611:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 711:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 811:06:51.943 [pool-1-thread-1] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test1 - example1 - 911:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 011:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 111:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 211:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 311:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 411:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 511:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 611:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 711:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 811:06:51.943 [pool-1-thread-2] INFO com.imooc.concurrency.example.sycn.SynchronizedExample2 - test2 - example2 - 9 可以看到修饰类和方法的时候 不同的对象和不同的线程 ex1 和ex2 依旧保持顺序执行 ex1执行完后ex2开始执行，由此可得 在synchronized修饰类和静态方法时 对这个类的所有对象都生效","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"CAS(ConmpareAndSwap)","slug":"CAS-ConmpareAndSwap","date":"2022-02-18T06:59:30.000Z","updated":"2022-02-18T07:25:28.001Z","comments":true,"path":"2022/02/18/CAS-ConmpareAndSwap/","link":"","permalink":"http://example.com/2022/02/18/CAS-ConmpareAndSwap/","excerpt":"","text":"简介（网络摘录）​ 在计算机科学中，比较和交换（Conmpare And Swap）是用于实现多线程同步的原子指令。它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果该值在同一时间被另一个线程更新，则写入将失败。操作结果必须说明是否进行替换; 这可以通过一个简单的布尔响应（这个变体通常称为比较和设置），或通过返回从内存位置读取的值来完成。 ​ CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” ​ 通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。 ​ 类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。 CAS的问题 ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 关于ABA问题参考文档: http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html 2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j&#x3D;a，合并一下ij&#x3D;2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 Java中CAS的实现（学习总结）atomic说到java中的cas不得不提atomic 以atomic中的AtomicInteger中的incrementAndGet方法为例 123456789101112131415public final int incrementAndGet() &#123;return unsafe.getAndAddInt(this, valueOffset, 1) + 1; &#125; public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125; 主要看unsafe的getAndAddInt方法的实现 var1 为当前atomicInteger var2为当前值 var5为底层值 var4为更新量 可以看到循环 会不停的从底层取出最新的var5和var2对比 当 var5&#x3D;var2时 才会执行更新操作var5+var4 保证了原子性 如何解决cas的aba问题atomic中AtomicStampedReference 解决了这个问题 为每一步修改操作加上版本号，比如原数据为0 版本号为0 一个线程修改原数据为1 后 版本号也为1 再把原数据修改成0 版本号却变成了2 另一个线程通过cas对比后虽然数据还是0但是版本号已经改变了 这样就避免了aba问题","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程","slug":"多线程","date":"2022-02-16T09:10:39.000Z","updated":"2022-02-16T09:12:37.960Z","comments":true,"path":"2022/02/16/多线程/","link":"","permalink":"http://example.com/2022/02/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"新博客的第一篇文章","slug":"新博客的第一篇文章","date":"2022-02-16T09:03:32.000Z","updated":"2022-02-16T09:07:03.507Z","comments":true,"path":"2022/02/16/新博客的第一篇文章/","link":"","permalink":"http://example.com/2022/02/16/%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"​ 很久没写作了，工作中很多有用的没有积累下来，之前的博客由于服务器的到期数据没留下来 新开一个博客放在自己的电脑上重新维护，2022年新的开始，加油。 希望每次我偷懒的时候看到这篇文章都可以想到写这篇文章时候下的决心。 ​ 2022.02.16","categories":[{"name":"new","slug":"new","permalink":"http://example.com/categories/new/"}],"tags":[{"name":"新的开始","slug":"新的开始","permalink":"http://example.com/tags/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"}]},{"title":"aaa","slug":"aaa","date":"2022-02-16T07:32:35.000Z","updated":"2022-02-16T08:50:49.313Z","comments":true,"path":"2022/02/16/aaa/","link":"","permalink":"http://example.com/2022/02/16/aaa/","excerpt":"","text":"","categories":[{"name":"suibianxiexie","slug":"suibianxiexie","permalink":"http://example.com/categories/suibianxiexie/"}],"tags":[{"name":"第一篇文章","slug":"第一篇文章","permalink":"http://example.com/tags/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-02-16T06:53:03.240Z","updated":"2022-02-16T06:53:03.240Z","comments":true,"path":"2022/02/16/hello-world/","link":"","permalink":"http://example.com/2022/02/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://example.com/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"new","slug":"new","permalink":"http://example.com/categories/new/"},{"name":"suibianxiexie","slug":"suibianxiexie","permalink":"http://example.com/categories/suibianxiexie/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"新的开始","slug":"新的开始","permalink":"http://example.com/tags/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"},{"name":"第一篇文章","slug":"第一篇文章","permalink":"http://example.com/tags/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"}]}